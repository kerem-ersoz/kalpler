<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hearts Table</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Layout: left = game (75%), right = chat (25%) */
  html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: Arial, Helvetica, sans-serif; background: #202123; color: #fff; }
  #root { height: 100%; display: flex; flex-direction: row; }

  #leftPane { flex: 3; display: flex; flex-direction: column; align-items: center; height: 100%; }
  #rightPane { flex: 1; height: 100%; background: rgba(255,255,255,0.03); display: flex; flex-direction: column; }

  /* Top row inside left pane */
  #topRow { width: 100%; display: flex; justify-content: space-between; align-items: flex-start; padding: 8px 12px; box-sizing: border-box; }
  #lastTrickBox { width: 220px; height: 120px; background: rgba(0,0,0,0.22); border-radius: 8px; padding: 8px; box-sizing: border-box; }
  #lastTrickBox h4 { margin: 0 0 6px 0; font-size: 13px; color: #ffd; }
  #lastTrickCards { display: flex; gap: 6px; align-items: center; justify-content: center; height: 74px; }
  .mini-card { width: 38px; height: 56px; background: #fff; color:#000; display:flex; align-items:center; justify-content:center; font-weight:700; border-radius:4px; box-shadow: 1px 1px 4px rgba(0,0,0,0.4); }

  #scoreboard { width: 260px; height: 120px; background: rgba(0,0,0,0.22); border-radius: 8px; padding: 8px; box-sizing: border-box; }
  #scoreboard h4 { margin: 0 0 6px 0; font-size: 13px; color: #ffd; }
  #scoreList { display: flex; flex-direction: column; gap: 6px; font-size: 14px; }

  /* Big oval table area (70% viewport height) */
  #tableWrap { width: 96%; max-width: 1200px; height: 70vh; margin-top: 8px; position: relative; display:flex; align-items:center; justify-content:center; }
  #table {
    width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, #1f3b1f 40%, #0e1a0e 100%);
    border-radius: 50% / 60%;
    box-shadow: inset 0 10px 40px rgba(0,0,0,0.4);
    position: relative; overflow: hidden;
  }

  .seat { position: absolute; width: 140px; height: 34px; text-align: center; display: flex; align-items: center; justify-content:center; border-radius: 18px; background: rgba(0,0,0,0.35); font-weight: bold; }
  .seat.current { box-shadow: 0 0 10px #ffd54f; background: #ffd54f; color: #000; }
  .seat.pos0 { bottom: 12px; left: 50%; transform: translateX(-50%); }
  .seat.pos1 { left: 12px; top: 50%; transform: translateY(-50%); }
  .seat.pos2 { top: 12px; left: 50%; transform: translateX(-50%); }
  .seat.pos3 { right: 12px; top: 50%; transform: translateY(-50%); }

  #centerTrick { position: absolute; width: 360px; height: 240px; left: 50%; top: 50%; transform: translate(-50%,-50%); }
  .ct-card { position: absolute; width: 64px; height: 96px; border-radius:6px; background: #fff; color: #000; display:flex; align-items:center; justify-content:center; font-weight:bold; box-shadow: 2px 2px 8px rgba(0,0,0,0.6); }
  .ct-card.south { bottom: 6px; left: 50%; transform: translateX(-50%); }
  .ct-card.west { left: 6px; top: 50%; transform: translateY(-50%); }
  .ct-card.north { top: 6px; left: 50%; transform: translateX(-50%); }
  .ct-card.east { right: 6px; top: 50%; transform: translateY(-50%); }

  #statusBar { height: 36px; margin-top: 6px; display:flex; align-items:center; justify-content:center; font-weight:bold; }

  #handArea { width: 96%; max-width: 1200px; height: 150px; margin-top: 6px; display:flex; align-items:center; justify-content:center; }
  #hand { width: 100%; display:flex; justify-content:center; gap:8px; overflow: hidden; padding: 8px 12px; box-sizing: border-box; }
  .card {
    width: 60px; height: 90px; border-radius: 6px; background: #fff; color: #000; display:flex; align-items:center; justify-content:center; font-weight:700;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.6); cursor: pointer; user-select: none; transition: transform 0.18s ease;
  }
  .card.red { color: #c00; }
  .card.disabled { opacity: 0.35; cursor: default; pointer-events: none; transform: none !important; }
  .card.playable:hover { transform: translateY(-10px); } /* hover lift only if playable */

  /* Rematch */
  #rematchBox { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.85); padding: 16px 18px; border-radius: 10px; display:none; z-index: 2000; }
  #rematchBox h3 { margin: 0 0 8px 0; font-size: 18px; color: #ffd; }
  #rematchBtn { padding: 8px 14px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; }
  #rematchStatus { margin-top: 8px; color: #ddd; font-size: 14px; }

  /* Chat (right pane) */
  #chatHeader { padding: 10px; font-weight: bold; border-bottom: 1px solid rgba(255,255,255,0.15); display:flex; justify-content:space-between; align-items:center; }
  #typing { font-size: 12px; color: #ccc; font-style: italic; }
  #chatMessages { flex: 1; padding: 10px; display: flex; flex-direction: column; gap: 6px; overflow: hidden; }
  #chatInputBar { padding: 10px; display: flex; gap: 8px; border-top: 1px solid rgba(255,255,255,0.15); }
  #chatText { flex: 1; border: none; border-radius: 6px; padding: 8px; font-size: 14px; background:#2a2b2e; color:#fff; }
  #chatSend { border: none; border-radius: 6px; padding: 8px 12px; background: #27ae60; color: #fff; font-weight: bold; cursor: pointer; }
  .chatLine { background: rgba(255,255,255,0.06); padding: 6px 8px; border-radius: 6px; font-size: 13px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
  .chatName { font-weight: 700; }
</style>
</head>
<body>
<div id="root">
  <div id="leftPane">
    <div id="topRow">
      <div id="lastTrickBox">
        <h4>Last completed trick</h4>
        <div id="lastTrickCards"><span style="opacity:0.6">— none —</span></div>
      </div>
      <div></div>
      <div id="scoreboard">
        <h4>Scoreboard</h4>
        <div id="scoreList"></div>
      </div>
    </div>

    <div id="tableWrap">
      <div id="table">
        <div id="playersOnTable"></div>
        <div id="centerTrick"></div>
      </div>
      <div id="rematchBox">
        <h3>Game over — rematch?</h3>
        <button id="rematchBtn">Request Rematch</button>
        <div id="rematchStatus"></div>
      </div>
    </div>

    <div id="statusBar">Not connected</div>
    <div id="handArea"><div id="hand"></div></div>
  </div>

  <div id="rightPane">
    <div id="chatHeader">
      <div>Table Chat</div>
      <div id="typing"></div>
    </div>
    <div id="chatMessages"></div>
    <div id="chatInputBar">
      <input id="chatText" placeholder="Type a message…" maxlength="300" />
      <button id="chatSend">Send</button>
    </div>
  </div>
</div>

<!-- Join Overlay -->
<div id="joinOverlay" style="position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.75); display:flex; align-items:center; justify-content:center; z-index:3000;">
  <div style="background:#2a2b2e; padding:18px; border-radius:10px; color:#fff; width:360px; text-align:center;">
    <h2 style="margin-top:0;">Join Game</h2>
    <input id="nameInput" placeholder="Display name" style="width:80%; padding:8px; border-radius:6px; border:none; margin-bottom:10px; background:#3a3b3e; color:#fff;" />
    <div>
      <button id="joinBtn" style="padding:8px 12px; border-radius:8px; background:#27ae60; color:white; border:none; cursor:pointer;">Join</button>
    </div>
    <div style="margin-top:8px; color:#ddd;">Waiting players:</div>
    <div id="waitingList" style="margin-top:8px; color:#ffd; display:flex; flex-direction:column; gap:6px; align-items:center;"></div>
    <div id="joinError" style="color:#f88; margin-top:8px;"></div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  // Join overlay
  const joinOverlay = document.getElementById('joinOverlay');
  const nameInput = document.getElementById('nameInput');
  const joinBtn = document.getElementById('joinBtn');
  const waitingList = document.getElementById('waitingList');
  const joinError = document.getElementById('joinError');

  // Game UI
  const lastTrickCards = document.getElementById('lastTrickCards');
  const scoreList = document.getElementById('scoreList');
  const playersOnTable = document.getElementById('playersOnTable');
  const centerTrick = document.getElementById('centerTrick');
  const handDiv = document.getElementById('hand');
  const statusBar = document.getElementById('statusBar');
  const rematchBox = document.getElementById('rematchBox');
  const rematchBtn = document.getElementById('rematchBtn');
  const rematchStatus = document.getElementById('rematchStatus');

  // Chat UI
  const chatMessages = document.getElementById('chatMessages');
  const chatText = document.getElementById('chatText');
  const chatSend = document.getElementById('chatSend');
  const typingEl = document.getElementById('typing');

  // State
  let playerId = null;
  let players = [];
  let hand = [];
  let scores = {};
  let currentTrick = [];
  let lastTrick = null;
  let turnPlayerId = null;
  let heartsBroken = false;
  let firstTrick = false;
  let finished = false;

  // Animations
  let prevHand = [];
  let prevTrick = [];
  let suppressCenterRenderFor = null; // {playerId, card} — delay drawing until fly-out finishes
  let trickAnimInProgress = false;
  let localAnimatingCard = null; // card code currently animating from this client

  // Chat colors
  const chatColors = ["#ff6b6b","#feca57","#48dbfb","#1dd1a1","#c8b6ff","#f368e0","#54a0ff","#ff9f43"];
  function colorForPlayer(id) {
    if (!players || !players.length) return "#ffd54f";
    const idx = players.findIndex(p => p.id === id);
    if (idx === -1) { let h = 0; for (let i=0;i<id.length;i++) h = (h*31 + id.charCodeAt(i))|0; return chatColors[Math.abs(h)%chatColors.length]; }
    return chatColors[idx % chatColors.length];
  }

  /* ---------- Join ---------- */
  joinBtn.onclick = () => {
    const name = nameInput.value.trim();
    if (!name) { joinError.textContent = "Enter a name"; return; }
    joinBtn.disabled = true;
    socket.emit('join', name);
  };

  socket.on('joinFailed', (data) => {
    joinError.textContent = data.reason || "Join failed";
    joinBtn.disabled = false;
  });

  socket.on('joinSuccess', (data) => {
    playerId = data.playerId;
    players = data.players || [];
    updateWaitingList();
    joinOverlay.style.display = 'none';
    statusBar.textContent = "Connected — waiting for players...";
  });

  socket.on('updatePlayers', (data) => {
    players = data.players || [];
    updateWaitingList();
    renderSeats();
  });

  /* ---------- Game state ---------- */
  socket.on('startGame', (state) => {
    applyState(state);
    rematchBox.style.display = 'none';
    trickAnimInProgress = false;
    localAnimatingCard = null;
    renderAll();
    statusBar.textContent = finished ? "Game ended" : (turnPlayerId === playerId ? "Your turn" : "Waiting for turn");
    if (lastTrick) showLastTrick(lastTrick); else clearLastTrick();
  });

  socket.on('updateGame', (state) => {
    if (!trickAnimInProgress) {
      animateIfMyCardPlayedFallback(state); // fallback if proactive click didn't run
    }
    applyState(state);
    renderAll();
    statusBar.textContent = finished ? "Game ended" : (turnPlayerId === playerId ? "Your turn" : "Waiting for turn");
    if (lastTrick) showLastTrick(lastTrick);
    if (!lastTrick && state.lastCompletedTrick == null) clearLastTrick();
  });

  socket.on('lastTrick', (trick) => {
    if (!trick) { clearLastTrick(); return; }
    showLastTrick(trick);
  });

  // Trick complete animation (server sends before clearing)
  socket.on('trickComplete', ({ trick, winnerId }) => {
    trickAnimInProgress = true;

    // Don't render center cards during trick-take; use flyers only to avoid overlap
    centerTrick.innerHTML = '';

    // Animate from center positions to winner, with a tiny pause so the 4th card is visible
    animateTrickTakeFromData(trick, winnerId, () => {
      trickAnimInProgress = false; // server will follow up with lastTrick + updateGame
    });
  });

  socket.on('roundEnd', (payload) => {
    scores = payload.scores || {};
    finished = payload.gameEnded || false;
    renderScores();
    statusBar.textContent = finished ? "Game ended" : "Round ended";
    if (finished) {
      rematchBox.style.display = 'block';
      rematchStatus.textContent = "Awaiting rematch votes...";
    }
  });

  socket.on('rematchStatus', (payload) => {
    const total = (payload.needed || []).length;
    const got = (payload.votes || []).length;
    rematchStatus.textContent = `Votes: ${got} / ${total}`;
  });

  socket.on('gameEnded', (payload) => {
    scores = payload.scores || {};
    finished = true;
    rematchBox.style.display = 'block';
    rematchStatus.textContent = "Request rematch?";
    renderScores();
  });

  socket.on('playError', (data) => {
    statusBar.textContent = data.reason || "Play error";
  });

  /* ---------- Chat ---------- */
  chatSend.onclick = sendChat;
  chatText.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); sendChat(); return; }
    sendTypingPing();
  });
  chatText.addEventListener("input", () => sendTypingPing());

  let typingTimeout = null;
  function sendTypingPing() {
    socket.emit("typing", chatText.value.trim().length > 0);
    if (typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => socket.emit("typing", false), 1200);
  }

  function sendChat() {
    const t = chatText.value.trim();
    if (!t) return;
    socket.emit("chatMessage", t);
    chatText.value = "";
    socket.emit("typing", false);
  }

  socket.on("chat", (payload) => {
    addChatLine(payload.line, colorForPlayer(payload.playerId));
  });

  socket.on("typingUpdate", (names) => {
    typingEl.textContent = names && names.length ? ("Typing: " + names.join(", ")) : "";
  });

  function addChatLine(line, color) {
    const div = document.createElement('div');
    div.className = 'chatLine';
    const closeIdx = line.indexOf(']');
    const colonIdx = line.indexOf(']:');
    if (closeIdx !== -1 && colonIdx !== -1 && colonIdx > closeIdx) {
      const head = line.slice(0, 1); // '['
      const middle = line.slice(1, closeIdx); // "HH:MM:SS Name"
      const rest = line.slice(closeIdx + 1); // "]: message"
      const lastSpace = middle.lastIndexOf(' ');
      if (lastSpace !== -1) {
        const timePart = middle.slice(0, lastSpace);
        const namePart = middle.slice(lastSpace + 1);
        div.innerHTML = `${head}${timePart} <span class="chatName" style="color:${color}">${namePart}</span>]${rest}`;
      } else {
        div.textContent = line;
      }
    } else {
      div.textContent = line;
    }
    chatMessages.appendChild(div);
    while (chatMessages.children.length > 14) chatMessages.removeChild(chatMessages.firstChild);
  }

  /* ---------- Rendering ---------- */
  function updateWaitingList() {
    waitingList.innerHTML = '';
    players.forEach(p => {
      const el = document.createElement('div');
      el.textContent = p.name;
      el.style.padding = '4px 6px';
      el.style.borderRadius = '6px';
      el.style.background = 'rgba(255,255,255,0.06)';
      el.style.width = '80%';
      el.style.textAlign = 'center';
      waitingList.appendChild(el);
    });
  }

  function renderSeats() {
    playersOnTable.innerHTML = '';
    if (!playerId) return;
    const myIndex = players.findIndex(p => p.id === playerId);
    for (let i = 0; i < players.length; i++) {
      const idx = (myIndex + i) % players.length;
      const p = players[idx];
      const el = document.createElement('div');
      el.className = 'seat pos' + i + (p && p.id === turnPlayerId ? ' current' : '');
      el.textContent = p ? p.name : 'Waiting';
      playersOnTable.appendChild(el);
    }
  }

  function renderCenterTrick() {
    // Avoid drawing center cards while trick-take animation is running
    if (trickAnimInProgress) return;

    centerTrick.innerHTML = '';
    if (!players.length) return;
    const myIndex = players.findIndex(p => p.id === playerId);
    currentTrick.forEach(play => {
      if (suppressCenterRenderFor && play.playerId === suppressCenterRenderFor.playerId && play.card === suppressCenterRenderFor.card) {
        return; // delay drawing this one until fly-out ends
      }
      const pIndex = players.findIndex(pp => pp.id === play.playerId);
      const rel = (pIndex - myIndex + players.length) % players.length;
      const cardEl = document.createElement('div');
      cardEl.className = 'ct-card ' + (rel === 0 ? 'south' : rel === 1 ? 'west' : rel === 2 ? 'north' : 'east');
      cardEl.textContent = prettyCard(play.card);
      if (isRed(play.card)) cardEl.style.color = '#c00';
      centerTrick.appendChild(cardEl);
    });
  }

  function renderHand() {
    // local suit ordering S,H,C,D (mirrors server)
    const suitOrder = { S: 0, H: 1, C: 2, D: 3 };
    const rankOrder = { "2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"J":11,"Q":12,"K":13,"A":14 };
    const sorted = hand.slice().sort((a,b) => suitOrder[a.slice(-1)] - suitOrder[b.slice(-1)] || rankOrder[a.slice(0,-1)] - rankOrder[b.slice(0,-1)]);

    handDiv.innerHTML = '';
    sorted.forEach(c => {
      const el = document.createElement('div');
      el.className = 'card';
      el.dataset.card = c;
      el.textContent = prettyCard(c);
      if (isRed(c)) el.classList.add('red');

      const playable = isCardPlayable(c);
      if (!playable) el.classList.add('disabled');
      else el.classList.add('playable'); // hover lift

      el.onclick = () => {
        if (!playable || finished) return;
        // Proactive fly-out animation for EVERY play
        animatePlayFromHand(c);
        socket.emit('playCard', c);
      };
      handDiv.appendChild(el);
    });
  }

  function renderScores() {
    scoreList.innerHTML = '';
    players.forEach(p => {
      const div = document.createElement('div');
      div.textContent = `${p.name}: ${scores[p.id] || 0}`;
      scoreList.appendChild(div);
    });
  }

  function renderAll() {
    renderSeats();
    renderCenterTrick();
    renderHand();
    renderScores();
  }

  function showLastTrick(trick) {
    lastTrickCards.innerHTML = '';
    trick.forEach(t => {
      const mc = document.createElement('div');
      mc.className = 'mini-card';
      mc.textContent = prettyCard(t.card);
      if (isRed(t.card)) mc.style.color = '#c00';
      lastTrickCards.appendChild(mc);
    });
  }
  function clearLastTrick() {
    lastTrickCards.innerHTML = '<span style="opacity:0.6">— none —</span>';
  }

  /* ---------- Helpers ---------- */
  function applyState(state) {
    prevHand = hand.slice();
    prevTrick = currentTrick.slice();

    hand = state.hand || [];
    scores = state.scores || {};
    currentTrick = state.currentTrick || [];
    lastTrick = state.lastCompletedTrick || null;
    turnPlayerId = state.turnPlayerId;
    heartsBroken = !!state.heartsBroken;
    firstTrick = !!state.firstTrick;
    finished = !!state.finished;
  }

  function prettyCard(code) {
    const suit = code.slice(-1);
    const rank = code.slice(0, -1);
    const m = { C: '♣', D: '♦', H: '♥', S: '♠' };
    return rank + m[suit];
  }
  function isRed(code) { return ['H','D'].includes(code.slice(-1)); }

  function isCardPlayable(card) {
    if (finished) return false;
    if (turnPlayerId !== playerId) return false;
    if (firstTrick && currentTrick.length === 0) return card === '2C';
    if (currentTrick.length === 0) {
      const isHeartSuit = card.slice(-1) === 'H';
      if (!heartsBroken && isHeartSuit) {
        const hasNonHearts = hand.some(c => c.slice(-1) !== 'H');
        if (hasNonHearts) return false;
      }
      return true;
    } else {
      const leadSuit = currentTrick[0].card.slice(-1);
      const hasLead = hand.some(c => c.slice(-1) === leadSuit);
      if (hasLead) return card.slice(-1) === leadSuit;
      return true;
    }
  }

  /* ---------- Proactive fly-out on click ---------- */
  function animatePlayFromHand(card) {
    const srcEl = handDiv.querySelector(`[data-card="${card}"]`);
    if (!srcEl) return;

    localAnimatingCard = card;
    suppressCenterRenderFor = { playerId, card };

    const srcRect = srcEl.getBoundingClientRect();
    requestAnimationFrame(() => {
      const tableRect = centerTrick.getBoundingClientRect();
      const targetX = tableRect.left + tableRect.width / 2 - 32;
      const targetY = tableRect.top + tableRect.height - 6 - 96;

      const flyer = document.createElement('div');
      flyer.className = 'card' + (isRed(card) ? ' red' : '');
      flyer.style.position = 'fixed';
      flyer.style.left = srcRect.left + 'px';
      flyer.style.top = srcRect.top + 'px';
      flyer.style.margin = '0';
      flyer.style.zIndex = 4000;
      flyer.style.transition = 'transform 240ms ease';
      flyer.textContent = prettyCard(card);
      document.body.appendChild(flyer);

      const dx = targetX - srcRect.left;
      const dy = targetY - srcRect.top;
      requestAnimationFrame(() => { flyer.style.transform = `translate(${dx}px, ${dy}px)`; });

      flyer.addEventListener('transitionend', () => {
        flyer.remove();
        suppressCenterRenderFor = null;
        localAnimatingCard = null;
        // Draw it on the table right after the animation
        renderCenterTrick();
      }, { once: true });
    });
  }

  /* ---------- Fallback fly-out (diff-based) ---------- */
  function animateIfMyCardPlayedFallback(nextState) {
    const nextHand = nextState.hand || [];
    const nextTrick = nextState.currentTrick || [];
    const removed = prevHand.filter(c => !nextHand.includes(c));
    if (removed.length !== 1) return;

    const myPlay = nextTrick.find(t => t.playerId === playerId && t.card === removed[0]);
    if (!myPlay) return;
    if (localAnimatingCard && localAnimatingCard === myPlay.card) return;

    const srcEl = handDiv.querySelector(`[data-card="${myPlay.card}"]`);
    if (!srcEl) return;

    suppressCenterRenderFor = { playerId, card: myPlay.card };

    const srcRect = srcEl.getBoundingClientRect();
    requestAnimationFrame(() => {
      const tableRect = centerTrick.getBoundingClientRect();
      const targetX = tableRect.left + tableRect.width / 2 - 32;
      const targetY = tableRect.top + tableRect.height - 6 - 96;

      const flyer = document.createElement('div');
      flyer.className = 'card' + (isRed(myPlay.card) ? ' red' : '');
      flyer.style.position = 'fixed';
      flyer.style.left = srcRect.left + 'px';
      flyer.style.top = srcRect.top + 'px';
      flyer.style.margin = '0';
      flyer.style.zIndex = 4000;
      flyer.style.transition = 'transform 240ms ease';
      flyer.textContent = prettyCard(myPlay.card);
      document.body.appendChild(flyer);

      const dx = targetX - srcRect.left;
      const dy = targetY - srcRect.top;
      requestAnimationFrame(() => { flyer.style.transform = `translate(${dx}px, ${dy}px)`; });

      flyer.addEventListener('transitionend', () => {
        flyer.remove();
        suppressCenterRenderFor = null;
        renderCenterTrick();
      }, { once: true });
    });
  }

  /* ---------- Trick take animation from data (no center DOM; flyers only) ---------- */
  function animateTrickTakeFromData(trick, winnerId, done) {
    const myIndex = players.findIndex(p => p.id === playerId);
    const winnerIndex = players.findIndex(p => p.id === winnerId);
    const winnerRel = (winnerIndex - myIndex + players.length) % players.length;

    const seatEl = document.querySelector('.seat.pos' + winnerRel);
    const seatRect = seatEl ? seatEl.getBoundingClientRect() : centerTrick.getBoundingClientRect();
    const targetX = seatRect.left + seatRect.width / 2 - 30; // center - half card width
    const targetY = seatRect.top + seatRect.height / 2 - 45; // center - half card height

    const cRect = centerTrick.getBoundingClientRect();
    const posToXY = (rel) => {
      if (rel === 0) { // south
        return { x: cRect.left + cRect.width / 2 - 32, y: cRect.bottom - 6 - 96 };
      } else if (rel === 1) { // west
        return { x: cRect.left + 6, y: cRect.top + cRect.height / 2 - 48 };
      } else if (rel === 2) { // north
        return { x: cRect.left + cRect.width / 2 - 32, y: cRect.top + 6 };
      } else { // east
        return { x: cRect.right - 6 - 64, y: cRect.top + cRect.height / 2 - 48 };
      }
    };

    let remaining = trick.length;
    if (remaining === 0) { done && done(); return; }

    const flyers = [];

    trick.forEach(play => {
      const pIndex = players.findIndex(pp => pp.id === play.playerId);
      const rel = (pIndex - myIndex + players.length) % players.length;
      const origin = posToXY(rel);

      const flyer = document.createElement('div');
      flyer.className = 'card' + (isRed(play.card) ? ' red' : '');
      flyer.style.position = 'fixed';
      flyer.style.left = origin.x + 'px';
      flyer.style.top = origin.y + 'px';
      flyer.style.margin = '0';
      flyer.style.zIndex = 4000;
      flyer.style.transition = 'transform 300ms ease, opacity 160ms ease';
      flyer.textContent = prettyCard(play.card);
      document.body.appendChild(flyer);
      flyers.push(flyer);
    });

    // Tiny pause so the 4th card is visible at center before moving
    setTimeout(() => {
      flyers.forEach(flyer => {
        const dx = targetX - parseFloat(flyer.style.left);
        const dy = targetY - parseFloat(flyer.style.top);
        requestAnimationFrame(() => { flyer.style.transform = `translate(${dx}px, ${dy}px)`; flyer.style.opacity = '0.35'; });
        flyer.addEventListener('transitionend', () => {
          flyer.remove();
          remaining--;
          if (remaining === 0) {
            centerTrick.innerHTML = ''; // ensure empty after animation
            done && done();
          }
        }, { once: true });
      });
    }, 80);
  }
</script>
</body>
</html>
